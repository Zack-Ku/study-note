# 垃圾回收算法
https://zackku.com/jvm-gc-base/

- **标记-清除算法（Mark-Sweep）**：标记垃圾再清除，内存碎片多。
- **复制算法**：内存分两块，把存活移到另一块，清空原来的那块。内存空间少，速度快，常用于新生代。
- **标记-整理算法（Mark-Compact）**：标记存活、垃圾，把对象移到内存一端。空间使用率高，计算大，常用于老年代。
- **分代收集**：把内存划分多个区域（代），个人不同区域用不同算法

新生代，对象存活率低，比较适用复制算法。老年代存活率高，比较适用Mark-Compact算法

# 垃圾回收器
https://zackku.com/jvm-gc-collector/

​       ----新生代---

- **Serial**：串行回收，复制算法，暂停所有线程。新生代用，区域小，停顿短

- **ParNew**：Serial的并行版本，复制算法，暂停所有线程。新生代用

- **Parallel Scavenge**：与ParNew类似，复制算法，但关注回收吞吐量，设置最大停顿时间/GC总占比时间。

  -----老年代----

- **Serial Old**：串行回收，标记-整理算法。老年代用，因为老年代存活率高，极端情况下无法使用复制算法

- **Parallel Old**：Parallel Scavenge的老年代版本，使用标记-整理算法，同样关注吞吐。

- **CMS**：并发回收，标记-清除，内存碎片多。1.初始标记STW，2.并发标记，3.重新标记STW，4.并发清理。不能用标记-整理，因为不能影响其他线程执行。
  整体

- **G1**：1.7启用，解决CMS，分相同大小Region，避免碎片化。分代不连续，需要维护Remembered Set的表，方便搜索分代。

- **ZGC**：着色指针在运行时改变内存状态，读屏障在有着色指针时发生，更新指针再返回结果。

# 虚拟机查询命令

- **jstack**（常用）：查看进程各线程堆栈，线程卡在哪里，大部分现在在执行什么；
- **jstat**（常用）：查看JVM统计信息，主要看GC情况和内存（新生代、老年代）分布；
- **jmap**（常用）：dump内存快照，配合jhat分析内存快照。查看哪里内存主要在哪些类
- **jinfo**：查看虚拟机配置信息

# 类加载机制
https://www.cnblogs.com/fanjie/p/6916784.html
http://www.importnew.com/25295.html

**类加载过程**：加载->连接（验证、准备、解析）->初始化

- **加载**：classLoader把编译好的.class文件加载到内存。也可以从zip\jar包中加载。
- **连接**：包含验证、准备、解析
  - **验证**：校验class文件的合法性
  - **准备**：分配类的静态属性内存，设定JVM默认值
  - **解析**：把类中的符号引用转化为直接引用。相当于把调用的函数添加一个实际的地址，例如b()、B这些符号赋予指针地址。
- **初始化**：开始执行类中的内容。主要是设定静态属性值、执行静态块等

# 运行时数据区
https://blog.csdn.net/fanxing1964/article/details/79349824
https://zackku.com/jvm-RAM-model/

JVM内存管理分配

- **虚拟机栈**：线程私有。执行每个方法时会添加一个栈帧，其中包含方法的局部变量、操作数、动态链接方法（连接到调用的具体类）、返回地址。
- **本地方法栈**：线程私有。与虚拟机栈类似，本地方法栈用于native方法。
- **程序计数器**：线程私有。指向线程执行的地址，在cpu切换线程时，从该指向地址开始执行。
- **方法区**：线程共享。大部分静态信息，包含加载好的类信息、常量、静态变量、JIT的代码。
- **堆**：线程共享。存放对象实例、数据。新生代、老年代都在这里。

# 双亲委派模型
https://www.cnblogs.com/aspirant/p/7200523.html

用于判断实例的类是否相同，关键是否同一个类加载器ClassLoader造出来的。

类加载器是个Java类，也是需要类加载器加载的，所以除了**启动类加载器（顶层类加载器）**外，所有类都有一个父类加载器（非继承，仅是加载关系）。

双亲委派模型，就是所有类加载请求都会落到最顶层的启动类加载器，如果自身类加载器加载不了（类不在范围里面），则会在下一层类加载器尝试加载。

优点：

1. 因为加载尝试顺序是固定的，那么同一个类就不会给多个类加载器加载；
2. 每个加载器只加载自己范围的类。

# 强引用、弱引用、软引用、虚引用
https://www.cnblogs.com/fengbs/p/7019687.html

- **强引用**：new一个对象出来就是强引用。不会被回收，如果该对象在方法中，那么当退出栈后，对象可以被回收。全局变量则不可回收
- **软引用**：当内存不足时，会被回收。SoftReference类。
- **弱引用**：gc扫描到就会回收。
- **虚引用**：主要追踪对象被gc活动，需配合引用队列。

软引用、弱引用常用于加载一些大量资源，避免程序OOM溢出。

# monitor GC、major GC、full GC

- **monitor GC**：年轻代的垃圾回收，频繁
- **Major GC**： 是清理老年代
- **full GC**：清理整个堆空间—包括年轻代和永久代。

# Java内存模型（JMM）

http://www.importnew.com/18126.html

来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

**规则**：所有的变量都是存在主存当中（类似于物理内存），每个线程都有自己的工作内存（类似于高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。变量在工作内存中执行完才能写回主存当中。

**原子性**：对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。自增操作不是原子。更大的原子性需要用锁。

**可见性**：如果被volidate修饰的变量值被修改，值会立即写回主存，实现可见性。

**有序性**：在遵守happen-before原则下，会保证指令的有序性，否则虚拟机可以随便重排。

**happen-before原则**：

1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
2. 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

# volidate 关键字

**两层含义**：

1. volidate变量具有可见性（不具有原子性），线程会立即知道该变量的最新值。即修改值的工作内存会立即刷到主内存。

   具体过程是修改变量的工作内存会刷到主存，然后会让其他线程的工作内存对应变量失效，从而从主存中获取。

2. volidate禁止指令重排。会使含volidate变量的语句在固定的位置，保证后面的语句不会到前面，前面的语句不会到后面。

**实现原理**：volatile的汇编上会加上lock前缀。lock相当于内存屏障，其作用是1.保证指令不重排，2.强制将缓存写入主存，3.如果是写操作会到导致其他缓存无效。



# 参数调优





